
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Goroutines &#8212; Learn TLA+</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <script src="../_static/js/petite-vue.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Glossary" href="../reference/glossary.html" />
    <link rel="prev" title="Partitions" href="partitions.html" /> 
  </head><body data-dark_mode_code_blocks="true">

<div id="top_nav">
    

    <nav>
        
            
        

        <p id="toggle_sidebar">
            <a href="#" title="Toggle sidebar">|||</a>
        </p>
        <h1><a href="../index.html" title="Go to homepage">Learn TLA+</a></h1>

        <a id="mode_toggle" href="#" @click.prevent="handleClick" :title="mode">
    <template v-if="mode == 'light'">
        <svg width="100%" height="100%" viewBox="0 0 79 80" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g id="mode_light"><rect id="Bounds" x="0" y="-0" width="78.623" height="79.049" style="fill:none;"/><circle cx="39.311" cy="39.524" r="15.734" style="fill:#fff;"/><g id="beams"><g id="beam"><path id="beam1" serif:id="beam" d="M44.212,4.901c0,-2.705 -2.196,-4.901 -4.901,-4.901c-2.704,-0 -4.9,2.196 -4.9,4.901l-0,9.614c-0,2.705 2.196,4.901 4.9,4.901c2.705,0 4.901,-2.196 4.901,-4.901l0,-9.614Z" style="fill:#fff;"/></g><g id="beam2" serif:id="beam"><path id="beam3" serif:id="beam" d="M67.48,18.073c1.913,-1.912 1.913,-5.018 0,-6.931c-1.912,-1.912 -5.018,-1.912 -6.931,0l-6.798,6.799c-1.912,1.912 -1.912,5.018 0,6.931c1.913,1.912 5.018,1.912 6.931,-0l6.798,-6.799Z" style="fill:#fff;"/></g><g id="beam4" serif:id="beam"><path id="beam5" serif:id="beam" d="M25.728,61.108c1.912,-1.913 1.912,-5.018 -0,-6.931c-1.913,-1.913 -5.019,-1.913 -6.931,-0l-6.799,6.798c-1.912,1.913 -1.912,5.019 0,6.931c1.913,1.913 5.019,1.913 6.931,0l6.799,-6.798Z" style="fill:#fff;"/></g><g id="beam6" serif:id="beam"><path id="beam7" serif:id="beam" d="M60.682,54.177c-1.913,-1.913 -5.018,-1.913 -6.931,-0c-1.912,1.913 -1.912,5.018 0,6.931l6.798,6.798c1.913,1.913 5.019,1.913 6.931,0c1.913,-1.912 1.913,-5.018 0,-6.931l-6.798,-6.798Z" style="fill:#fff;"/></g><g id="beam8" serif:id="beam"><path id="beam9" serif:id="beam" d="M4.901,34.623c-2.705,0 -4.901,2.196 -4.901,4.901c0,2.705 2.196,4.901 4.901,4.901l9.614,0c2.705,0 4.901,-2.196 4.901,-4.901c0,-2.705 -2.196,-4.901 -4.901,-4.901l-9.614,0Z" style="fill:#fff;"/></g><g id="beam10" serif:id="beam"><path id="beam11" serif:id="beam" d="M44.212,64.534c0,-2.705 -2.196,-4.901 -4.901,-4.901c-2.704,-0 -4.9,2.196 -4.9,4.901l-0,9.614c-0,2.705 2.196,4.901 4.9,4.901c2.705,-0 4.901,-2.196 4.901,-4.901l0,-9.614Z" style="fill:#fff;"/></g><g id="beam12" serif:id="beam"><path id="beam13" serif:id="beam" d="M18.929,11.142c-1.912,-1.912 -5.018,-1.912 -6.931,0c-1.912,1.913 -1.912,5.019 0,6.931l6.799,6.799c1.912,1.912 5.018,1.912 6.931,-0c1.912,-1.913 1.912,-5.019 -0,-6.931l-6.799,-6.799Z" style="fill:#fff;"/></g><g id="beam14" serif:id="beam"><path id="beam15" serif:id="beam" d="M64.108,34.623c-2.705,0 -4.901,2.196 -4.901,4.901c-0,2.705 2.196,4.901 4.901,4.901l9.614,0c2.705,0 4.901,-2.196 4.901,-4.901c-0,-2.705 -2.196,-4.901 -4.901,-4.901l-9.614,0Z" style="fill:#fff;"/></g></g></g></svg>
    </template>

    <template v-if="mode == 'dark'">
        <svg width="100%" height="100%" viewBox="0 0 79 80" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g id="mode_dark"><rect id="Bounds" x="0" y="-0" width="78.623" height="79.049" style="fill:none;"/><circle cx="39.311" cy="39.524" r="15.734" style="fill:#fff;"/><g id="beams"><g id="beam"><path id="beam1" serif:id="beam" d="M44.212,14.515c0,-2.705 -2.196,-4.901 -4.901,-4.901c-2.704,0 -4.901,2.196 -4.901,4.901c0,2.705 2.197,4.901 4.901,4.901c2.705,0 4.901,-2.196 4.901,-4.901Z" style="fill:#fff;"/></g><g id="beam2" serif:id="beam"><path id="beam3" serif:id="beam" d="M60.662,24.892c1.902,-1.902 1.902,-4.99 0,-6.892l-0.04,-0.039c-1.901,-1.902 -4.989,-1.902 -6.891,-0c-1.901,1.901 -1.901,4.989 0,6.891l0.04,0.04c1.902,1.901 4.989,1.901 6.891,-0Z" style="fill:#fff;"/></g><g id="beam4" serif:id="beam"><path id="beam5" serif:id="beam" d="M25.732,61.103c1.91,-1.91 1.91,-5.011 0,-6.921l-0.009,-0.01c-1.91,-1.91 -5.012,-1.91 -6.921,-0c-1.91,1.91 -1.91,5.011 -0,6.921l0.01,0.01c1.909,1.91 5.011,1.91 6.92,-0Z" style="fill:#fff;"/></g><g id="beam6" serif:id="beam"><path id="beam7" serif:id="beam" d="M60.672,54.167c-1.907,-1.907 -5.004,-1.907 -6.911,0l-0.02,0.02c-1.907,1.907 -1.907,5.004 0,6.911c1.907,1.907 5.004,1.907 6.911,-0l0.02,-0.02c1.907,-1.907 1.907,-5.004 0,-6.911Z" style="fill:#fff;"/></g><g id="beam8" serif:id="beam"><path id="beam9" serif:id="beam" d="M14.52,34.623c-2.702,0 -4.896,2.194 -4.896,4.896l0,0.01c0,2.702 2.194,4.896 4.896,4.896c2.702,0 4.896,-2.194 4.896,-4.896l-0,-0.01c-0,-2.702 -2.194,-4.896 -4.896,-4.896Z" style="fill:#fff;"/></g><g id="beam10" serif:id="beam"><path id="beam11" serif:id="beam" d="M44.212,64.534c0,-2.705 -2.196,-4.901 -4.901,-4.901c-2.704,-0 -4.901,2.196 -4.901,4.901c0,2.704 2.197,4.9 4.901,4.9c2.705,0 4.901,-2.196 4.901,-4.9Z" style="fill:#fff;"/></g><g id="beam12" serif:id="beam"><path id="beam13" serif:id="beam" d="M25.73,17.943c-1.911,-1.911 -5.015,-1.911 -6.926,0l-0.005,0.005c-1.911,1.911 -1.911,5.015 0,6.926c1.911,1.911 5.015,1.911 6.926,0l0.005,-0.005c1.911,-1.911 1.911,-5.014 -0,-6.926Z" style="fill:#fff;"/></g><g id="beam14" serif:id="beam"><path id="beam15" serif:id="beam" d="M64.098,34.623c-2.699,0 -4.891,2.192 -4.891,4.892l-0,0.019c-0,2.699 2.192,4.891 4.891,4.891c2.7,0 4.892,-2.192 4.892,-4.891l0,-0.019c0,-2.7 -2.192,-4.892 -4.892,-4.892Z" style="fill:#fff;"/></g></g></g></svg>
    </template>

    <template v-if="mode == 'darkest'">
        <svg width="100%" height="100%" viewBox="0 0 79 80" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g id="mode_darkest"><rect id="Bounds" x="0" y="-0" width="78.623" height="79.049" style="fill:none;"/><path d="M39.315,23.791c8.684,-0 15.734,7.05 15.734,15.733c0,8.684 -7.05,15.734 -15.734,15.734c-8.683,0 -15.733,-7.05 -15.733,-15.734c-0,-8.683 7.05,-15.733 15.733,-15.733Zm0,4.737c6.069,0 10.997,4.927 10.997,10.996c-0,6.069 -4.928,10.996 -10.997,10.996c-6.068,0 -10.996,-4.927 -10.996,-10.996c0,-6.069 4.928,-10.996 10.996,-10.996Z" style="fill:#fff;"/><g id="beams"><g id="beam"><path id="beam1" serif:id="beam" d="M44.216,14.515c0,-2.705 -2.196,-4.901 -4.901,-4.901c-2.704,0 -4.9,2.196 -4.9,4.901c-0,2.705 2.196,4.901 4.9,4.901c2.705,0 4.901,-2.196 4.901,-4.901Z" style="fill:#fff;"/></g><g id="beam2" serif:id="beam"><path id="beam3" serif:id="beam" d="M60.666,24.892c1.902,-1.902 1.902,-4.99 0,-6.892l-0.04,-0.039c-1.901,-1.902 -4.989,-1.902 -6.891,-0c-1.901,1.901 -1.901,4.989 0,6.891l0.04,0.04c1.902,1.901 4.99,1.901 6.891,-0Z" style="fill:#fff;"/></g><g id="beam4" serif:id="beam"><path id="beam5" serif:id="beam" d="M25.737,61.103c1.909,-1.91 1.909,-5.011 -0,-6.921l-0.01,-0.01c-1.91,-1.91 -5.011,-1.91 -6.921,-0c-1.91,1.91 -1.91,5.011 -0,6.921l0.01,0.01c1.91,1.91 5.011,1.91 6.921,-0Z" style="fill:#fff;"/></g><g id="beam6" serif:id="beam"><path id="beam7" serif:id="beam" d="M60.676,54.167c-1.907,-1.907 -5.004,-1.907 -6.911,0l-0.02,0.02c-1.907,1.907 -1.907,5.004 0,6.911c1.907,1.907 5.004,1.907 6.911,-0l0.02,-0.02c1.907,-1.907 1.907,-5.004 0,-6.911Z" style="fill:#fff;"/></g><g id="beam8" serif:id="beam"><path id="beam9" serif:id="beam" d="M14.524,34.623c-2.702,0 -4.896,2.194 -4.896,4.896l0,0.01c0,2.702 2.194,4.896 4.896,4.896c2.702,0 4.896,-2.194 4.896,-4.896l0,-0.01c0,-2.702 -2.194,-4.896 -4.896,-4.896Z" style="fill:#fff;"/></g><g id="beam10" serif:id="beam"><path id="beam11" serif:id="beam" d="M44.216,64.534c0,-2.705 -2.196,-4.901 -4.901,-4.901c-2.704,-0 -4.9,2.196 -4.9,4.901c-0,2.704 2.196,4.9 4.9,4.9c2.705,0 4.901,-2.196 4.901,-4.9Z" style="fill:#fff;"/></g><g id="beam12" serif:id="beam"><path id="beam13" serif:id="beam" d="M25.734,17.943c-1.911,-1.911 -5.015,-1.911 -6.926,0l-0.005,0.005c-1.911,1.911 -1.911,5.015 0,6.926c1.911,1.911 5.015,1.911 6.926,0l0.005,-0.005c1.911,-1.911 1.911,-5.014 0,-6.926Z" style="fill:#fff;"/></g><g id="beam14" serif:id="beam"><path id="beam15" serif:id="beam" d="M64.103,34.623c-2.7,0 -4.892,2.192 -4.892,4.892l-0,0.019c-0,2.699 2.192,4.891 4.892,4.891c2.699,0 4.891,-2.192 4.891,-4.891l0,-0.019c0,-2.7 -2.192,-4.892 -4.891,-4.892Z" style="fill:#fff;"/></g></g></g></svg>
    </template>
</a>

<script>
(function() {
    const LOCAL_STORAGE_KEY = 'piccoloThemeMode'

    var initialMode = localStorage.getItem(LOCAL_STORAGE_KEY)

    if (initialMode) {
        // Make sure the value in local storage is valid
        if (['light', 'dark', 'darkest'].indexOf(initialMode) == -1) {
            initialMode = 'light'
            localStorage.setItem(LOCAL_STORAGE_KEY, initialMode)
        }
    } else {
        // Check if the client prefers dark mode
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            initialMode = 'dark'
        } else {
            initialMode = 'light'
        }
        localStorage.setItem(LOCAL_STORAGE_KEY, initialMode)
    }

    document.documentElement.dataset.mode = initialMode

    PetiteVue.createApp({
        'mode': initialMode,
        handleClick() {
            let currentMode = this.mode

            if (currentMode == 'light') {
                this.mode = 'dark'
            } else if (currentMode == 'dark') {
                this.mode = 'darkest'
            } else if (currentMode == 'darkest') {
                this.mode = 'light'
            }

            document.documentElement.dataset.mode = this.mode
            localStorage.setItem(LOCAL_STORAGE_KEY, this.mode)

            console.log(this.mode)
        }
    }).mount('#mode_toggle')
})()
</script>
            <p class="mobile_search_link">
                <a href="../search.html" title="Search">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 65 64" fill-rule="evenodd" stroke-linejoin="round" stroke-miterlimit="2">
                        <path d="M14.873 40.009c-2.315-3.943-3.642-8.532-3.642-13.429C11.231 11.91 23.141 0 37.811 0s26.58 11.91 26.58 26.58-11.91 26.58-26.58 26.58a26.44 26.44 0 0 1-14.277-4.161L9.739 62.794a3.12 3.12 0 0 1-4.413 0L.913 58.382c-1.217-1.218-1.217-3.196 0-4.413l13.96-13.96zM37.811 8.054c10.225 0 18.526 8.301 18.526 18.526s-8.301 18.526-18.526 18.526-18.526-8.301-18.526-18.526S27.586 8.054 37.811 8.054z" fill="#fff" />
                    </svg>
                </a>
            </p>
        

        <div class="searchbox_wrapper">
            
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
    </nav>
</div>

    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">Intro</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intro/faq.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../whatsnew.html">What’s New</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intro/conceptual-overview.html">Conceptual Overview</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">TLA+</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../core/index.html">Core</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topics/index.html">Topics</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Examples</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="index.html">Operators</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html#pluscal-specs">PlusCal Specs</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Goroutines</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../reference/glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../reference/standard-library.html">Standard Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../reference/other-resources.html">Other Resources</a></li>
</ul>

<ul>
  <li class="toctree-l1"><a href= "../genindex.html">Index</a></li>
</ul>
        </div>
      </div>



    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="goroutines">
<span id="example-goroutines"></span><h1>Goroutines<a class="headerlink" href="#goroutines" title="Permalink to this headline">¶</a></h1>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This example was originally published on <a class="reference external" href="https://hillelwayne.com/post/tla-golang/">my blog</a> and is adapted here with minor revisions.</p>
</div>
<p>In <a class="reference external" href="https://utcc.utoronto.ca/~cks/space/blog/programming/GoConcurrencyStillNotEasy">Even in Go, concurrency is still not
easy</a>, Chris Siebenmann gives an example of Go code which deadlocks:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="w">  </span><span class="kd">func</span><span class="w"> </span><span class="nx">FindAll</span><span class="p">()</span><span class="w"> </span><span class="p">[]</span><span class="nx">P</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">//P = process data</span><span class="w"></span>
<span class="linenos"> 2</span><span class="w">     </span><span class="nx">pss</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">ps</span><span class="p">.</span><span class="nx">Processes</span><span class="p">()</span><span class="w"></span>
<span class="linenos"> 3</span><span class="w">     </span><span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="w"></span>
<span class="linenos"> 4</span><span class="w">     </span><span class="nx">found</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="nx">P</span><span class="p">)</span><span class="w"></span>
<span class="linenos"> 5</span><span class="w">     </span><span class="nx">limitCh</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="kd">struct</span><span class="p">{},</span><span class="w"> </span><span class="nx">concurrencyProcesses</span><span class="p">)</span><span class="w"></span>
<span class="linenos"> 6</span>
<span class="linenos"> 7</span><span class="w">     </span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">pr</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">pss</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 8</span><span class="w">        </span><span class="nx">limitCh</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="kd">struct</span><span class="p">{}{}</span><span class="w"></span>
<span class="linenos"> 9</span><span class="w">        </span><span class="nx">pr</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">pr</span><span class="w"></span>
<span class="linenos">10</span><span class="w">        </span><span class="k">go</span><span class="w"> </span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">11</span><span class="w">           </span><span class="k">defer</span><span class="w"> </span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">&lt;-</span><span class="nx">limitCh</span><span class="w"> </span><span class="p">}()</span><span class="w"></span>
<span class="linenos">12</span><span class="w">           </span><span class="p">[</span><span class="o">...</span><span class="w"> </span><span class="nx">get</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="nx">P</span><span class="w"> </span><span class="nx">with</span><span class="w"> </span><span class="nx">some</span><span class="w"> </span><span class="kt">error</span><span class="w"> </span><span class="nx">checking</span><span class="w"> </span><span class="o">...</span><span class="p">]</span><span class="w"></span>
<span class="linenos">13</span><span class="w">           </span><span class="nx">found</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nx">P</span><span class="w"></span>
<span class="linenos">14</span><span class="w">        </span><span class="p">}()</span><span class="w"></span>
<span class="linenos">15</span><span class="w">     </span><span class="p">}</span><span class="w"></span>
<span class="linenos">16</span><span class="w">     </span><span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="w"></span>
<span class="linenos">17</span>
<span class="linenos">18</span><span class="w">     </span><span class="kd">var</span><span class="w"> </span><span class="nx">results</span><span class="w"> </span><span class="p">[]</span><span class="nx">P</span><span class="w"></span>
<span class="linenos">19</span><span class="w">     </span><span class="k">for</span><span class="w"> </span><span class="nx">p</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">found</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">20</span><span class="w">        </span><span class="nx">results</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">results</span><span class="p">,</span><span class="w"> </span><span class="nx">p</span><span class="p">)</span><span class="w"></span>
<span class="linenos">21</span><span class="w">     </span><span class="p">}</span><span class="w"></span>
<span class="linenos">22</span><span class="w">     </span><span class="k">return</span><span class="w"> </span><span class="nx">results</span><span class="w"></span>
<span class="linenos">23</span><span class="w">  </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>In his words:</p>
<blockquote class="quote">
<div><p>The bug is that the goroutines only receive from limitCh to release their token after sending their result to the unbuffered found channel, while the main code only starts receiving from found after running through the entire loop, and the main code takes the token in the loop and blocks if no tokens are available.</p>
</div></blockquote>
<p>This is a good example of directly verifying code with a TLA+ spec, instead of verifying just a design.</p>
<section id="planning-ahead">
<h2>Planning Ahead<a class="headerlink" href="#planning-ahead" title="Permalink to this headline">¶</a></h2>
<p>It’s good to start with some upfront thinking of how we are going to
approach this problem. There’s two parts to formally specifying
something: describing the system and describing the properties of the
system. In this case we can ignore the second part, since we’re only
looking for deadlocks. It would be good modeling practice to add sanity
check properties, like type invariants, but they are not strictly
necessary.</p>
<p>First, we want to pick whether we’ll model in TLA+ or PlusCal. Since the Go code is highly sequential, I will use PlusCal. This will cause a bit of impedance
mismatch down the road for unbuffered channels but overall it’s a net
benefit.</p>
<p>There are three “complex bits” to Chris’s code sample: <code class="docutils literal notranslate"><span class="pre">go</span></code>,
<code class="docutils literal notranslate"><span class="pre">defer</span></code>, and the nature of Go channels. <code class="docutils literal notranslate"><span class="pre">defer</span></code> runs cleanup code
when a goroutine is finished running. For now we’ll represent this by
moving the deferred code to its own label, but we could also use a
PlusCal procedure to be more accurate. <code class="docutils literal notranslate"><span class="pre">go</span></code> spawns a new goroutine.
Since PlusCal requires us to define all of our processes in advance, we
can’t “spawn” a new goroutine. What we can do instead is define each
process but prevent them from running. Then we add a flag that says
whether or not the goroutine was initialized in the behavior yet. It
would look something like this:</p>
<div class="highlight-tla notranslate"><div class="highlight"><pre><span></span><span class="n">variables</span>
  <span class="n">initialized</span> <span class="o">=</span> <span class="p">[</span><span class="n">w</span> <span class="s">\in</span> <span class="n">Routines</span> <span class="o">|-&gt;</span> <span class="bp">FALSE</span><span class="p">];</span>

<span class="c">\* ...</span>

<span class="nt">process</span> <span class="n">goroutine</span> <span class="s">\in</span> <span class="n">Routines</span>
<span class="nf">begin</span>
<span class="nt">  Work:</span>
    <span class="ld">await</span> <span class="n">initialized</span><span class="p">[</span><span class="n">self</span><span class="p">];</span>
<span class="c">\* ...</span>
</pre></div>
</div>
<p>So each goroutine <code class="docutils literal notranslate"><span class="pre">awaits</span></code> being initialized by the main process
before it does anything. This is how we can emulate spawning new
processes.</p>
<p>That leaves the channels, which are the most complicated part to
specify. There are two kinds of Go channels: buffered and unbuffered.
Sends to a buffered channel are blocked if the channel is full. Receives
from a buffered channel are blocked if the channel is empty. Both of
these are representable with PlusCal macros:</p>
<div class="highlight-tla notranslate"><div class="highlight"><pre><span></span><span class="nf">macro</span> <span class="n">send_buffered</span><span class="p">(</span><span class="n">chan</span><span class="p">)</span> <span class="nf">begin</span>
  <span class="ld">await</span> <span class="n">channels</span><span class="p">[</span><span class="n">chan</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">buffered</span><span class="p">[</span><span class="n">chan</span><span class="p">];</span>
  <span class="n">channels</span><span class="p">[</span><span class="n">chan</span><span class="p">]</span> <span class="o">:=</span> <span class="n">channels</span><span class="p">[</span><span class="n">chan</span><span class="p">]</span> <span class="o">+</span> <span class="m">1</span><span class="p">;</span>
<span class="nf">end macro</span><span class="p">;</span>

<span class="nf">macro</span> <span class="n">receive_buffered</span><span class="p">(</span><span class="n">chan</span><span class="p">)</span> <span class="nf">begin</span>
  <span class="ld">await</span> <span class="n">channels</span><span class="p">[</span><span class="n">chan</span><span class="p">]</span> <span class="o">&gt;</span> <span class="m">0</span><span class="p">;</span>
  <span class="n">channels</span><span class="p">[</span><span class="n">chan</span><span class="p">]</span> <span class="o">:=</span> <span class="n">channels</span><span class="p">[</span><span class="n">chan</span><span class="p">]</span> <span class="o">-</span> <span class="m">1</span><span class="p">;</span>
<span class="nf">end macro</span><span class="p">;</span>
</pre></div>
</div>
<p>That covers buffered channels. Unbuffered channels, by contrast, always
block unless there is <em>both</em> a sender and receiver. In pure TLA+ this
wouldn’t be too tricky to specify, but PlusCal assumes each step of the
behavior is one process doing one thing. Unbuffered channels can’t be
represented natively without adding some annoying bookkeeping, as we
need to have one process block “first”. For that we can use a <a class="reference internal" href="../core/concurrency.html#procedure"><span class="std std-ref">Procedures</span></a>.</p>
<p>So now that we know a rough approach and what the pain points are likely
to be, let’s write the spec.</p>
</section>
<section id="the-spec">
<h2>The spec<a class="headerlink" href="#the-spec" title="Permalink to this headline">¶</a></h2>
<p>First the breakdown, then the whole spec.</p>
<div class="highlight-tla notranslate"><div class="highlight"><pre><span></span><span class="c c-PreProc">----</span> <span class="c c-PreProc">MODULE</span> <span class="c c-PreProc">channels</span> <span class="c c-PreProc">----</span>
<span class="kn">EXTENDS</span> <span class="n">Integers</span><span class="p">,</span> <span class="n">TLC</span><span class="p">,</span> <span class="n">Sequences</span>

<span class="kn">CONSTANTS</span> <span class="n">NumRoutines</span><span class="p">,</span> <span class="n">NumTokens</span>
<span class="n">Routines</span> <span class="o">==</span> <span class="m">1</span><span class="o">..</span><span class="n">NumRoutines</span>

<span class="nf">(* --algorithm channels</span>

<span class="n">variables</span>
  <span class="n">channels</span> <span class="o">=</span> <span class="p">[</span><span class="n">tokens</span> <span class="o">|-&gt;</span> <span class="m">0</span><span class="p">,</span> <span class="n">found</span> <span class="o">|-&gt;</span> <span class="n">{}</span><span class="p">];</span>
  <span class="n">buffered</span> <span class="o">=</span> <span class="p">[</span><span class="n">tokens</span> <span class="o">|-&gt;</span> <span class="n">NumTokens</span><span class="p">];</span>
  <span class="n">initialized</span> <span class="o">=</span> <span class="p">[</span><span class="n">w</span> <span class="s">\in</span> <span class="n">Routines</span> <span class="o">|-&gt;</span> <span class="bp">FALSE</span><span class="p">];</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">channels</span></code> is the current contents of each channel. For buffered
channels, we treat their contents as a single number and store the
maximum capacity in a separate <code class="docutils literal notranslate"><span class="pre">buffered</span></code> variable. For unbuffered
channels, we instead store the set of senders waiting for a receiver.
<code class="docutils literal notranslate"><span class="pre">initialized</span></code> is for emulating goroutines.</p>
<div class="highlight-tla notranslate"><div class="highlight"><pre><span></span><span class="nf">macro</span> <span class="n">go</span><span class="p">(</span><span class="n">routine</span><span class="p">)</span> <span class="nf">begin</span>
  <span class="n">initialized</span><span class="p">[</span><span class="n">routine</span><span class="p">]</span> <span class="o">:=</span> <span class="bp">TRUE</span><span class="p">;</span>
<span class="nf">end macro</span>
</pre></div>
</div>
<p>An extra macro I added to more closely match the Go syntax.</p>
<div class="highlight-tla notranslate"><div class="highlight"><pre><span></span><span class="nf">macro</span> <span class="n">write_buffered</span><span class="p">(</span><span class="n">chan</span><span class="p">)</span> <span class="nf">begin</span>
  <span class="ld">await</span> <span class="n">channels</span><span class="p">[</span><span class="n">chan</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">buffered</span><span class="p">[</span><span class="n">chan</span><span class="p">];</span>
  <span class="n">channels</span><span class="p">[</span><span class="n">chan</span><span class="p">]</span> <span class="o">:=</span> <span class="n">channels</span><span class="p">[</span><span class="n">chan</span><span class="p">]</span> <span class="o">+</span> <span class="m">1</span><span class="p">;</span>
<span class="nf">end macro</span><span class="p">;</span>

<span class="nf">macro</span> <span class="n">receive_channel</span><span class="p">(</span><span class="n">chan</span><span class="p">)</span> <span class="nf">begin</span>
  <span class="k">if</span> <span class="n">chan</span> <span class="s">\in</span> <span class="n">DOMAIN</span> <span class="n">buffered</span> <span class="k">then</span>
    <span class="ld">await</span> <span class="n">channels</span><span class="p">[</span><span class="n">chan</span><span class="p">]</span> <span class="o">&gt;</span> <span class="m">0</span><span class="p">;</span>
    <span class="n">channels</span><span class="p">[</span><span class="n">chan</span><span class="p">]</span> <span class="o">:=</span> <span class="n">channels</span><span class="p">[</span><span class="n">chan</span><span class="p">]</span> <span class="o">-</span> <span class="m">1</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="ld">await</span> <span class="n">channels</span><span class="p">[</span><span class="n">chan</span><span class="p">]</span> <span class="o">#</span> <span class="n">{}</span><span class="p">;</span>
    <span class="k">with</span> <span class="n">w</span> <span class="s">\in</span> <span class="n">channels</span><span class="p">[</span><span class="n">chan</span><span class="p">]</span> <span class="k">do</span>
      <span class="n">channels</span><span class="p">[</span><span class="n">chan</span><span class="p">]</span> <span class="o">:=</span> <span class="n">channels</span><span class="p">[</span><span class="n">chan</span><span class="p">]</span> <span class="o">\</span> <span class="n">{w}</span>
    <span class="k">end</span> <span class="k">with</span><span class="p">;</span>
  <span class="k">end</span> <span class="k">if</span><span class="p">;</span>
<span class="nf">end macro</span><span class="p">;</span>
</pre></div>
</div>
<p>This is a change from our old <code class="docutils literal notranslate"><span class="pre">read_buffered</span></code> because it handles both
buffered and unbuffered channels. Buffered channels work as expected.
For unbuffered channels, we wait for the set of blocked writers to be
nonempty and nondeterministically declare that we read from one of
them.<a class="footnote-reference brackets" href="#id6" id="id1">1</a></p>
<div class="highlight-tla notranslate"><div class="highlight"><pre><span></span><span class="nf">procedure</span> <span class="n">write_unbuffered</span><span class="p">(</span><span class="n">chan</span><span class="p">)</span> <span class="nf">begin</span>
<span class="nt">  DeclareSend:</span>
    <span class="n">channels</span><span class="p">[</span><span class="n">chan</span><span class="p">]</span> <span class="o">:=</span> <span class="n">channels</span><span class="p">[</span><span class="n">chan</span><span class="p">]</span> <span class="nb">\union</span> <span class="n">{self}</span><span class="p">;</span>
<span class="nt">  Send:</span>
    <span class="ld">await</span> <span class="n">self</span> <span class="s">\notin</span> <span class="n">channels</span><span class="p">[</span><span class="n">chan</span><span class="p">];</span>
    <span class="nf">return</span><span class="p">;</span>
<span class="nf">end procedure</span>
</pre></div>
</div>
<p>To model unbuffered channels we can either put state on senders or put
state on receivers. I opted to place it on the sender because Go permits
<a class="reference external" href="https://golang.org/ref/spec#Select_statements">reading from multiple unbuffered channels at
once</a>.<a class="footnote-reference brackets" href="#id7" id="id2">2</a> In two
separate temporal steps we 1) add the process to the set of channel
senders and 2) wait to be removed from that set by a receiver.</p>
<div class="highlight-tla notranslate"><div class="highlight"><pre><span></span><span class="nt">process</span> <span class="n">goroutine</span> <span class="s">\in</span> <span class="n">Routines</span>
<span class="nf">begin</span>
<span class="nt">  A:</span>
    <span class="ld">await</span> <span class="n">initialized</span><span class="p">[</span><span class="n">self</span><span class="p">];</span>
    <span class="k">call</span> <span class="n">write_unbuffered</span><span class="p">(</span><span class="s">&quot;found&quot;</span><span class="p">);</span>
<span class="nt">  B:</span>
    <span class="n">receive_channel</span><span class="p">(</span><span class="s">&quot;tokens&quot;</span><span class="p">);</span>
<span class="nf">end process</span><span class="p">;</span>
</pre></div>
</div>
<p>Our goroutine process is a straightforward translation of the Go code.
First we wait for the goroutine to be initialized, corresponding to line
10. Then we write to the <code class="docutils literal notranslate"><span class="pre">found</span></code> channel (line 13). If I was trying to
be more faithful I would write special <code class="docutils literal notranslate"><span class="pre">defer</span></code> semantics, but for this
I’m happy to just stick it on a label at the end of the process.</p>
<div class="highlight-tla notranslate"><div class="highlight"><pre><span></span><span class="nt">process</span> <span class="n">main</span> <span class="o">=</span> <span class="m">0</span>
<span class="n">variables</span> <span class="n">i</span> <span class="o">=</span> <span class="m">1</span><span class="p">;</span>
<span class="nf">begin</span>
<span class="nt">  Main:</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">NumRoutines</span> <span class="k">do</span>
      <span class="n">write_buffered</span><span class="p">(</span><span class="s">&quot;tokens&quot;</span><span class="p">);</span>
      <span class="n">go</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
      <span class="n">i</span> <span class="o">:=</span> <span class="n">i</span> <span class="o">+</span> <span class="m">1</span><span class="p">;</span>
    <span class="k">end</span> <span class="k">while</span><span class="p">;</span>
<span class="nt">  Get:</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="m">1</span> <span class="k">do</span>
      <span class="n">i</span> <span class="o">:=</span> <span class="n">i</span> <span class="o">-</span> <span class="m">1</span><span class="p">;</span>
      <span class="n">receive_channel</span><span class="p">(</span><span class="s">&quot;found&quot;</span><span class="p">);</span>
    <span class="k">end</span> <span class="k">while</span><span class="p">;</span>
<span class="nf">end process</span><span class="p">;</span>

<span class="nf">end algorithm; *)</span>
</pre></div>
</div>
<p>Our emulation uses one token to initialize each goroutine.
Since <code class="docutils literal notranslate"><span class="pre">write_channel</span></code> has an <code class="docutils literal notranslate"><span class="pre">await</span></code> in it, it will block if there
are more goroutines than tokens. It will then stay blocked until a
goroutine releases a token.<a class="footnote-reference brackets" href="#id8" id="id3">3</a> Final spec:</p>
<div class="highlight-tla notranslate"><div class="highlight"><pre><span></span><span class="c c-PreProc">----</span> <span class="c c-PreProc">MODULE</span> <span class="c c-PreProc">channels</span> <span class="c c-PreProc">----</span>
<span class="kn">EXTENDS</span> <span class="n">Integers</span><span class="p">,</span> <span class="n">TLC</span><span class="p">,</span> <span class="n">Sequences</span>

<span class="kn">CONSTANTS</span> <span class="n">NumRoutines</span><span class="p">,</span> <span class="n">NumTokens</span>

<span class="n">Routines</span> <span class="o">==</span> <span class="m">1</span><span class="o">..</span><span class="n">NumRoutines</span>

<span class="nf">(* --algorithm channels</span>

<span class="n">variables</span>
  <span class="n">channels</span> <span class="o">=</span> <span class="p">[</span><span class="n">limitCh</span> <span class="o">|-&gt;</span> <span class="m">0</span><span class="p">,</span> <span class="n">found</span> <span class="o">|-&gt;</span> <span class="n">{}</span><span class="p">];</span>
  <span class="n">buffered</span> <span class="o">=</span> <span class="p">[</span><span class="n">limitCh</span> <span class="o">|-&gt;</span> <span class="n">NumTokens</span><span class="p">];</span>
  <span class="n">initialized</span> <span class="o">=</span> <span class="p">[</span><span class="n">w</span> <span class="s">\in</span> <span class="n">Routines</span> <span class="o">|-&gt;</span> <span class="bp">FALSE</span><span class="p">];</span>


<span class="nf">macro</span> <span class="n">send_buffered</span><span class="p">(</span><span class="n">chan</span><span class="p">)</span> <span class="nf">begin</span>
  <span class="ld">await</span> <span class="n">channels</span><span class="p">[</span><span class="n">chan</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">buffered</span><span class="p">[</span><span class="n">chan</span><span class="p">];</span>
  <span class="n">channels</span><span class="p">[</span><span class="n">chan</span><span class="p">]</span> <span class="o">:=</span> <span class="n">channels</span><span class="p">[</span><span class="n">chan</span><span class="p">]</span> <span class="o">+</span> <span class="m">1</span><span class="p">;</span>
<span class="nf">end macro</span><span class="p">;</span>

<span class="nf">macro</span> <span class="n">receive_channel</span><span class="p">(</span><span class="n">chan</span><span class="p">)</span> <span class="nf">begin</span>
  <span class="k">if</span> <span class="n">chan</span> <span class="s">\in</span> <span class="n">DOMAIN</span> <span class="n">buffered</span> <span class="k">then</span>
    <span class="ld">await</span> <span class="n">channels</span><span class="p">[</span><span class="n">chan</span><span class="p">]</span> <span class="o">&gt;</span> <span class="m">0</span><span class="p">;</span>
    <span class="n">channels</span><span class="p">[</span><span class="n">chan</span><span class="p">]</span> <span class="o">:=</span> <span class="n">channels</span><span class="p">[</span><span class="n">chan</span><span class="p">]</span> <span class="o">-</span> <span class="m">1</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="ld">await</span> <span class="n">channels</span><span class="p">[</span><span class="n">chan</span><span class="p">]</span> <span class="o">#</span> <span class="n">{}</span><span class="p">;</span>
    <span class="k">with</span> <span class="n">w</span> <span class="s">\in</span> <span class="n">channels</span><span class="p">[</span><span class="n">chan</span><span class="p">]</span> <span class="k">do</span>
      <span class="n">channels</span><span class="p">[</span><span class="n">chan</span><span class="p">]</span> <span class="o">:=</span> <span class="n">channels</span><span class="p">[</span><span class="n">chan</span><span class="p">]</span> <span class="o">\</span> <span class="n">{w}</span>
    <span class="k">end</span> <span class="k">with</span><span class="p">;</span>
  <span class="k">end</span> <span class="k">if</span><span class="p">;</span>
<span class="nf">end macro</span><span class="p">;</span>

<span class="nf">macro</span> <span class="n">go</span><span class="p">(</span><span class="n">routine</span><span class="p">)</span> <span class="nf">begin</span>
  <span class="n">initialized</span><span class="p">[</span><span class="n">routine</span><span class="p">]</span> <span class="o">:=</span> <span class="bp">TRUE</span><span class="p">;</span>
<span class="nf">end macro</span>

<span class="nf">procedure</span> <span class="n">send_unbuffered</span><span class="p">(</span><span class="n">chan</span><span class="p">)</span> <span class="nf">begin</span>
<span class="nt">  DeclareSend:</span>
    <span class="n">channels</span><span class="p">[</span><span class="n">chan</span><span class="p">]</span> <span class="o">:=</span> <span class="n">channels</span><span class="p">[</span><span class="n">chan</span><span class="p">]</span> <span class="nb">\union</span> <span class="n">{self}</span><span class="p">;</span>
<span class="nt">  Send:</span>
    <span class="ld">await</span> <span class="n">self</span> <span class="s">\notin</span> <span class="n">channels</span><span class="p">[</span><span class="n">chan</span><span class="p">];</span>
    <span class="nf">return</span><span class="p">;</span>
<span class="nf">end procedure</span>

<span class="nt">process</span> <span class="n">goroutine</span> <span class="s">\in</span> <span class="n">Routines</span>
<span class="nf">begin</span>
<span class="nt">  A:</span>
    <span class="ld">await</span> <span class="n">initialized</span><span class="p">[</span><span class="n">self</span><span class="p">];</span>
    <span class="k">call</span> <span class="n">send_unbuffered</span><span class="p">(</span><span class="s">&quot;found&quot;</span><span class="p">);</span>
<span class="nt">  B:</span>
    <span class="n">receive_channel</span><span class="p">(</span><span class="s">&quot;limitCh&quot;</span><span class="p">);</span>
<span class="nf">end process</span><span class="p">;</span>

<span class="nt">process</span> <span class="n">main</span> <span class="o">=</span> <span class="m">0</span>
<span class="n">variables</span> <span class="n">i</span> <span class="o">=</span> <span class="m">1</span><span class="p">;</span>
<span class="nf">begin</span>
<span class="nt">  Main:</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">NumRoutines</span> <span class="k">do</span>
      <span class="n">send_buffered</span><span class="p">(</span><span class="s">&quot;limitCh&quot;</span><span class="p">);</span>
      <span class="n">go</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
      <span class="n">i</span> <span class="o">:=</span> <span class="n">i</span> <span class="o">+</span> <span class="m">1</span><span class="p">;</span>
    <span class="k">end</span> <span class="k">while</span><span class="p">;</span>
<span class="nt">  Get:</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="m">1</span> <span class="k">do</span>
      <span class="n">i</span> <span class="o">:=</span> <span class="n">i</span> <span class="o">-</span> <span class="m">1</span><span class="p">;</span>
      <span class="n">receive_channel</span><span class="p">(</span><span class="s">&quot;found&quot;</span><span class="p">);</span>
    <span class="k">end</span> <span class="k">while</span><span class="p">;</span>
<span class="nf">end process</span><span class="p">;</span>

<span class="nf">end algorithm; *)</span>
<span class="c c-PreProc">====</span>
</pre></div>
</div>
<p>Now that we have a full spec, we can use the model checker, TLC, to see
if it satisfies any properties. We didn’t specify any, but TLC will
check for deadlocks by default.</p>
</section>
<section id="finding-deadlocks">
<h2>Finding Deadlocks<a class="headerlink" href="#finding-deadlocks" title="Permalink to this headline">¶</a></h2>
<p>To make this deadlock, I checked it with <code class="docutils literal notranslate"><span class="pre">NumRoutines</span> <span class="pre">&lt;-</span> <span class="pre">3,</span> <span class="pre">NumTokens</span> <span class="pre">&lt;-</span> <span class="pre">2</span></code>. {{TODO state space}}. Unsurprisingly, this deadlocks:<a class="footnote-reference brackets" href="#id9" id="id4">5</a></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>State 1: &lt;Initial predicate&gt;
/\ buffered = [limitCh |-&gt; 2]
/\ channels = [limitCh |-&gt; 0, found |-&gt; {}]
/\ i = 1
/\ pc = (0 :&gt; &quot;Main&quot; @@ 1 :&gt; &quot;A&quot; @@ 2 :&gt; &quot;A&quot; @@ 3 :&gt; &quot;A&quot;)
/\ initialized = &lt;&lt;FALSE, FALSE, FALSE&gt;&gt;

State 2: &lt;Main line 128, col 9 to line 137, col 48 of module base&gt;
/\ buffered = [limitCh |-&gt; 2]
/\ channels = [limitCh |-&gt; 1, found |-&gt; {}]
/\ i = 2
/\ pc = (0 :&gt; &quot;Main&quot; @@ 1 :&gt; &quot;A&quot; @@ 2 :&gt; &quot;A&quot; @@ 3 :&gt; &quot;A&quot;)
/\ initialized = &lt;&lt;TRUE, FALSE, FALSE&gt;&gt;

State 3: &lt;Main line 128, col 9 to line 137, col 48 of module base&gt;
/\ buffered = [limitCh |-&gt; 2]
/\ channels = [limitCh |-&gt; 2, found |-&gt; {}]
/\ i = 3
/\ pc = (0 :&gt; &quot;Main&quot; @@ 1 :&gt; &quot;A&quot; @@ 2 :&gt; &quot;A&quot; @@ 3 :&gt; &quot;A&quot;)
/\ initialized = &lt;&lt;TRUE, TRUE, FALSE&gt;&gt;

State 4: &lt;A line 106, col 12 to line 114, col 64 of module base&gt;
/\ buffered = [limitCh |-&gt; 2]
/\ channels = [limitCh |-&gt; 2, found |-&gt; {}]
/\ i = 3
/\ pc = (0 :&gt; &quot;Main&quot; @@ 1 :&gt; &quot;A&quot; @@ 2 :&gt; &quot;DeclareSend&quot; @@ 3 :&gt; &quot;A&quot;)
/\ initialized = &lt;&lt;TRUE, TRUE, FALSE&gt;&gt;

State 5: &lt;A line 106, col 12 to line 114, col 64 of module base&gt;
/\ buffered = [limitCh |-&gt; 2]
/\ channels = [limitCh |-&gt; 2, found |-&gt; {}]
/\ i = 3
/\ pc = (0 :&gt; &quot;Main&quot; @@ 1 :&gt; &quot;DeclareSend&quot; @@ 2 :&gt; &quot;DeclareSend&quot; @@ 3 :&gt; &quot;A&quot;)
/\ initialized = &lt;&lt;TRUE, TRUE, FALSE&gt;&gt;

State 6: &lt;DeclareSend line 92, col 22 to line 95, col 77 of module base&gt;
/\ buffered = [limitCh |-&gt; 2]
/\ channels = [limitCh |-&gt; 2, found |-&gt; {1}]
/\ i = 3
/\ pc = (0 :&gt; &quot;Main&quot; @@ 1 :&gt; &quot;Send&quot; @@ 2 :&gt; &quot;DeclareSend&quot; @@ 3 :&gt; &quot;A&quot;)
/\ initialized = &lt;&lt;TRUE, TRUE, FALSE&gt;&gt;

State 7: &lt;DeclareSend line 92, col 22 to line 95, col 77 of module base&gt;
/\ buffered = [limitCh |-&gt; 2]
/\ channels = [limitCh |-&gt; 2, found |-&gt; {1, 2}]
/\ i = 3
/\ pc = (0 :&gt; &quot;Main&quot; @@ 1 :&gt; &quot;Send&quot; @@ 2 :&gt; &quot;Send&quot; @@ 3 :&gt; &quot;A&quot;)
/\ initialized = &lt;&lt;TRUE, TRUE, FALSE&gt;&gt;
</pre></div>
</div>
<p>It’s the same issue that Chris had. The goroutines can only return their
tokens if there is a receiver on the <code class="docutils literal notranslate"><span class="pre">found</span></code> channel, the only
receiver of that channel is <code class="docutils literal notranslate"><span class="pre">main</span></code>, <code class="docutils literal notranslate"><span class="pre">main</span></code> only reads after it
initializes all the goroutines, and <code class="docutils literal notranslate"><span class="pre">main</span></code> will block if there are
more goroutines than tokens. The goroutines can’t return tokens until
all goroutines are initialized, and main can’t initialize all goroutines
until some goroutines have returned their tokens.</p>
</section>
<section id="fixing-this">
<h2>Fixing This<a class="headerlink" href="#fixing-this" title="Permalink to this headline">¶</a></h2>
<p>Chris suggests three possible ways of fixing this. We can test each of
the three by modifying our spec:</p>
<blockquote class="quote">
<div><p>If the goroutines took the token by sending to <code class="docutils literal notranslate"><span class="pre">limitCh</span></code> instead of
the main for loop doing it, the bug would not exist;</p>
</div></blockquote>
<div class="highlight-diff notranslate"><div class="highlight"><pre><span></span><span class="w">process goroutine \in Routines</span>
<span class="w">begin</span>
<span class="w"> </span> A:<span class="w"></span>
<span class="w"> </span>   await initialized[self];<span class="w"></span>
<span class="gi">+   write_buffered(&quot;limitCh&quot;);</span><span class="w"></span>

<span class="w">\* ...</span>

<span class="w"> </span>   while i &lt;= NumRoutines do<span class="w"></span>
<span class="gd">-     write_buffered(&quot;limitCh&quot;);</span><span class="w"></span>
<span class="w"> </span>     initialized[i] := TRUE;<span class="w"></span>
<span class="w"> </span>     i := i + 1;<span class="w"></span>
<span class="w"> </span>   end while;<span class="w"></span>
</pre></div>
</div>
<p>This passes model checking.</p>
<blockquote class="quote">
<div><p>If the goroutines received from <code class="docutils literal notranslate"><span class="pre">limitCh</span></code> to release their token
before sending to <code class="docutils literal notranslate"><span class="pre">found</span></code>, it wouldn’t exist (but because of error
handling, it’s simpler and more reliable to do the receive in a
defer).</p>
</div></blockquote>
<div class="highlight-diff notranslate"><div class="highlight"><pre><span></span><span class="w">process goroutine \in Routines</span>
<span class="w">begin</span>
<span class="w"> </span>A:<span class="w"></span>
<span class="w"> </span>  await initialized[self];<span class="w"></span>
<span class="gi">+   receive_channel(&quot;limitCh&quot;);</span><span class="w"></span>
<span class="gd">-   call write_unbuffered(&quot;found&quot;);</span><span class="w"></span>
<span class="w"> </span>B:<span class="w"></span>
<span class="gd">-   receive_channel(&quot;limitCh&quot;);</span><span class="w"></span>
<span class="gi">+   call write_unbuffered(&quot;found&quot;);</span><span class="w"></span>
<span class="w">end process;</span>
</pre></div>
</div>
<p>This passes model checking.</p>
<blockquote class="quote">
<div><p>And if the entire for loop was in an additional goroutine…</p>
</div></blockquote>
<p>This one’s a little more complicated. We create a new process for the
loop and add its identifier to <code class="docutils literal notranslate"><span class="pre">initialized</span></code>. I’ll use <code class="docutils literal notranslate"><span class="pre">-1</span></code> to
represent the for-loop.</p>
<div class="highlight-tla notranslate"><div class="highlight"><pre><span></span><span class="n">initialized</span> <span class="o">=</span> <span class="p">[</span><span class="n">w</span> <span class="s">\in</span> <span class="n">Routines</span> <span class="nb">\union</span> <span class="n">{</span><span class="o">-</span><span class="m">1</span><span class="n">}</span> <span class="o">|-&gt;</span> <span class="bp">FALSE</span><span class="p">];</span>

<span class="c">\* After goroutines</span>

<span class="nt">process</span> <span class="n">for_loop</span> <span class="o">=</span> <span class="o">-</span><span class="m">1</span>
<span class="n">variables</span> <span class="n">i</span> <span class="o">=</span> <span class="m">1</span><span class="p">;</span>
<span class="nf">begin</span>
<span class="nt">  Loop:</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">NumRoutines</span> <span class="k">do</span>
      <span class="n">write_buffered</span><span class="p">(</span><span class="s">&quot;limitCh&quot;</span><span class="p">);</span>
      <span class="n">go</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
      <span class="n">i</span> <span class="o">:=</span> <span class="n">i</span> <span class="o">+</span> <span class="m">1</span><span class="p">;</span>
    <span class="k">end</span> <span class="k">while</span><span class="p">;</span>
<span class="nf">end process</span><span class="p">;</span>
</pre></div>
</div>
<p>Then we modify <code class="docutils literal notranslate"><span class="pre">main</span></code> to initialize this instead of doing the loop
itself:</p>
<div class="highlight-tla notranslate"><div class="highlight"><pre><span></span><span class="nt">process</span> <span class="n">main</span> <span class="o">=</span> <span class="m">0</span>
<span class="n">variables</span> <span class="n">i</span> <span class="o">=</span> <span class="n">NumRoutines</span><span class="p">;</span>
<span class="nf">begin</span>
<span class="nt">  Main:</span>
    <span class="n">go</span><span class="p">(</span><span class="o">-</span><span class="m">1</span><span class="p">);</span>
<span class="nt">  Get:</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="k">do</span>
      <span class="n">i</span> <span class="o">:=</span> <span class="n">i</span> <span class="o">-</span> <span class="m">1</span><span class="p">;</span>
      <span class="n">receive_channel</span><span class="p">(</span><span class="s">&quot;found&quot;</span><span class="p">);</span>
    <span class="k">end</span> <span class="k">while</span><span class="p">;</span>
<span class="nf">end process</span><span class="p">;</span>
</pre></div>
</div>
<p>This passes model checking.</p>
<section id="discussion">
<h3>Discussion<a class="headerlink" href="#discussion" title="Permalink to this headline">¶</a></h3>
<p>Ultimately we wrote about 75 lines of specification to test 20 lines of
Go code. Over half the spec is channel logic which we can now reuse in
other specs. Discounting those puts us a little closer, though I’ll
admit that a real TLA+ spec would be a lot longer because you’d be
writing a lot more sanity checking properties. Nonetheless, writing the
TLA+ version wouldn’t be significantly more effort than writing the
original version and could save you net time if it caught the deadlock
before production.</p>
<dl class="footnote brackets">
<dt class="label" id="id6"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">with</span></code> blocks if the set is empty, making the <code class="docutils literal notranslate"><span class="pre">await</span></code> statement
above it redundant. I added it purely for clarity.</p>
</dd>
<dt class="label" id="id7"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>You can also use a <code class="docutils literal notranslate"><span class="pre">select</span></code> to send to multiple channels, but I
think that’s less common? This is where being able to write a raw
TLA+ action could be really helpful.</p>
</dd>
<dt class="label" id="id8"><span class="brackets"><a class="fn-backref" href="#id3">3</a></span></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">Get</span></code> is an inaccurate representation of how channel receives in a
<code class="docutils literal notranslate"><span class="pre">range</span></code> work: it should loop until the channel is closed. I left
that out here because the rest of the spec doesn’t depend on closing
channels and I didn’t want to add extra complexity to this example.</p>
</dd>
<dt class="label" id="id9"><span class="brackets"><a class="fn-backref" href="#id4">5</a></span></dt>
<dd><p>I removed the <code class="docutils literal notranslate"><span class="pre">stack</span></code> and <code class="docutils literal notranslate"><span class="pre">chan</span></code> variables from the trace to make
it a little clearer.</p>
</dd>
</dl>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
    
        <div id="show_right_sidebar">
            <p><a class="toggle_right_sidebar" href="#"><span class="icon">&lt;</span><span>Page contents</span></a></p>
        </div>

        <div id="right_sidebar">
            <p><a class="toggle_right_sidebar" href="#"><span class="icon">&gt;</span><span>Page contents:</span></a></p>
            <div class="page_toc">
                <ul>
<li><a class="reference internal" href="#">Goroutines</a><ul>
<li><a class="reference internal" href="#planning-ahead">Planning Ahead</a></li>
<li><a class="reference internal" href="#the-spec">The spec</a></li>
<li><a class="reference internal" href="#finding-deadlocks">Finding Deadlocks</a></li>
<li><a class="reference internal" href="#fixing-this">Fixing This</a><ul>
<li><a class="reference internal" href="#discussion">Discussion</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            </div>
        </div>
    

      <div class="clearer"></div>
    </div>
    <div class="button_nav_wrapper">
        <div class="button_nav">
            <div class="left">
                
                <a href="partitions.html">
                    <span class="icon">&lt;</span><span>Partitions</span></a>
                
            </div>

            <div class="right">
                
                    <a href="../reference/glossary.html"><span>Glossary</span><span class="icon">&gt;</span></a>
                
            </div>
        </div>
    </div>


    <div class="footer" role="contentinfo">
        &#169; Copyright 2022, Hillel Wayne.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.4.0.
    </div>

<p id="theme_credit">Styled using the <a href="https://github.com/piccolo-orm/piccolo_theme">Piccolo Theme</a></p>
  </body>
</html>